{"ast":null,"code":"var _jsxFileName = \"/home/alyson/Desktop/Projetos/desafios/e-commerce/src/components/TopTags/index.jsx\";\nimport React, { Component } from 'react';\n\nclass TopTags extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  lookingForTags() {\n    /*\n    \tItera por todo o array de objetos e retorna um array bi-dimensional\n    \tcom todas as tags atribuídas aos produtos do e-commerce\n    */\n    const tags = this.props.data.map(eachProd => eachProd.arrTags);\n    /*\n    \tEm seguida são criados dois arrays, o primeiro armazenará\n    \tcada uma das tags e, o segundo, armazenará, respectivamente,\n    \ta quantidade de ocorrências de cada tag.\n    */\n\n    const topTags = [];\n    let eventNumber = [];\n    /*tags.map itera sobre a primeira dimensão do array tags*/\n\n    tags.map(occurrence =>\n    /*occurrence.map itera sobre a segunda dimensão do array tags*/\n    occurrence.map(eachTag =>\n    /*\n    \tSe a tag atual ainda não estiver armazenada no array topTags\n    \tela é inserida no final do array e também é atribuída uma \n    \tocorrência no array eventNumber; caso a tag já conste no array\n    \tsomente é atribuida oo vetor eventNuber, de forma respectiva\n    \ta seu index, mais uma ocorrência.\n    */\n    topTags.indexOf(eachTag) === -1 ? (topTags.push(eachTag), eventNumber.push(1)) : eventNumber[topTags.indexOf(eachTag)] += 1));\n    /*\n    \tAo final, o método retorna outro array bi-dimensional:\n    \to que consta no primeiro index indica a listagem\n    \tdas tags e, no segundo, a quantidade de ocorrências.\n    */\n\n    return [topTags, eventNumber];\n  }\n\n  render() {\n    const topTags = this.lookingForTags()[0];\n    const eventNumber = this.lookingForTags()[1];\n    const showTopTags = [];\n    /*\n    \tPara listar as 5 tags que mais se repetem, a cada iteração,\n    \té obtido o index daquela de maior ocorrência;\n    \testa é inserida no array showTopTags para ser renderizada;\n    \tna sequência ela é excluída do array de tags e também do de ocorrências;\n    \tassim, a próxima tag de mais relevância torna-se aquela com maior frequência\n    \tdessa forma o ciclo se repete até a quinta iteração.\n    */\n\n    for (let i = 0; i < 5; i++) {\n      let max = eventNumber.reduce((a, b) => {\n        return Math.max(a, b);\n      });\n      let pos = eventNumber.indexOf(max);\n      showTopTags.push(topTags[pos]);\n      topTags.splice(pos, 1);\n      eventNumber.splice(pos, 1);\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 73\n      },\n      __self: this\n    }, showTopTags.map((each, k) => React.createElement(\"p\", {\n      key: k,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75\n      },\n      __self: this\n    }, each)));\n  }\n\n}\n\nexport default TopTags;","map":{"version":3,"sources":["/home/alyson/Desktop/Projetos/desafios/e-commerce/src/components/TopTags/index.jsx"],"names":["React","Component","TopTags","constructor","props","state","lookingForTags","tags","data","map","eachProd","arrTags","topTags","eventNumber","occurrence","eachTag","indexOf","push","render","showTopTags","i","max","reduce","a","b","Math","pos","splice","each","k"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;;AAEA,MAAMC,OAAN,SAAsBD,SAAtB,CAAgC;AAC/BE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AAClB,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa,EAAb;AACA;;AAEDC,EAAAA,cAAc,GAAG;AAChB;;;;AAIA,UAAMC,IAAI,GAAG,KAAKH,KAAL,CAAWI,IAAX,CAAgBC,GAAhB,CAAqBC,QAAD,IAAeA,QAAQ,CAACC,OAA5C,CAAb;AACA;;;;;;AAKA,UAAMC,OAAO,GAAG,EAAhB;AACA,QAAIC,WAAW,GAAG,EAAlB;AACA;;AACAN,IAAAA,IAAI,CAACE,GAAL,CAAUK,UAAD;AACR;AACAA,IAAAA,UAAU,CAACL,GAAX,CAAgBM,OAAD;AACd;;;;;;;AAOCH,IAAAA,OAAO,CAACI,OAAR,CAAgBD,OAAhB,MAA6B,CAAC,CAA/B,IAECH,OAAO,CAACK,IAAR,CAAaF,OAAb,GACAF,WAAW,CAACI,IAAZ,CAAiB,CAAjB,CAHD,IAMCJ,WAAW,CAACD,OAAO,CAACI,OAAR,CAAgBD,OAAhB,CAAD,CAAX,IAAyC,CAd3C,CAFD;AAoBA;;;;;;AAKA,WAAO,CAACH,OAAD,EAAUC,WAAV,CAAP;AACA;;AAEDK,EAAAA,MAAM,GAAG;AACR,UAAMN,OAAO,GAAG,KAAKN,cAAL,GAAsB,CAAtB,CAAhB;AACA,UAAMO,WAAW,GAAG,KAAKP,cAAL,GAAsB,CAAtB,CAApB;AACA,UAAMa,WAAW,GAAG,EAApB;AACA;;;;;;;;;AAQA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsBA,CAAC,EAAvB,EAA2B;AAC1B,UAAIC,GAAG,GAAGR,WAAW,CAACS,MAAZ,CAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACtC,eAAOC,IAAI,CAACJ,GAAL,CAASE,CAAT,EAAYC,CAAZ,CAAP;AACA,OAFS,CAAV;AAGA,UAAIE,GAAG,GAAGb,WAAW,CAACG,OAAZ,CAAoBK,GAApB,CAAV;AACAF,MAAAA,WAAW,CAACF,IAAZ,CAAiBL,OAAO,CAACc,GAAD,CAAxB;AACAd,MAAAA,OAAO,CAACe,MAAR,CAAeD,GAAf,EAAoB,CAApB;AACAb,MAAAA,WAAW,CAACc,MAAZ,CAAmBD,GAAnB,EAAwB,CAAxB;AACA;;AACD,WACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACEP,WAAW,CAACV,GAAZ,CAAgB,CAACmB,IAAD,EAAOC,CAAP,KAChB;AAAG,MAAA,GAAG,EAAEA,CAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAYD,IAAZ,CADA,CADF,CADD;AAOA;;AA5E8B;;AA+EhC,eAAe1B,OAAf","sourcesContent":["import React, { Component } from 'react';\n\nclass TopTags extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {}\n\t}\n\n\tlookingForTags() {\n\t\t/*\n\t\t\tItera por todo o array de objetos e retorna um array bi-dimensional\n\t\t\tcom todas as tags atribuídas aos produtos do e-commerce\n\t\t*/\n\t\tconst tags = this.props.data.map((eachProd) => (eachProd.arrTags));\n\t\t/*\n\t\t\tEm seguida são criados dois arrays, o primeiro armazenará\n\t\t\tcada uma das tags e, o segundo, armazenará, respectivamente,\n\t\t\ta quantidade de ocorrências de cada tag.\n\t\t*/\n\t\tconst topTags = [];\n\t\tlet eventNumber = [];\n\t\t/*tags.map itera sobre a primeira dimensão do array tags*/\n\t\ttags.map((occurrence) => (\n\t\t\t/*occurrence.map itera sobre a segunda dimensão do array tags*/\n\t\t\toccurrence.map((eachTag) => (\n\t\t\t\t/*\n\t\t\t\t\tSe a tag atual ainda não estiver armazenada no array topTags\n\t\t\t\t\tela é inserida no final do array e também é atribuída uma \n\t\t\t\t\tocorrência no array eventNumber; caso a tag já conste no array\n\t\t\t\t\tsomente é atribuida oo vetor eventNuber, de forma respectiva\n\t\t\t\t\ta seu index, mais uma ocorrência.\n\t\t\t\t*/\n\t\t\t\t(topTags.indexOf(eachTag) === -1)\n\t\t\t\t? (\n\t\t\t\t\ttopTags.push(eachTag),\n\t\t\t\t\teventNumber.push(1)\n\t\t\t\t)\n\t\t\t\t: (\n\t\t\t\t\teventNumber[topTags.indexOf(eachTag)] += 1\n\t\t\t\t)\n\t\t\t))\n\t\t))\n\t\t/*\n\t\t\tAo final, o método retorna outro array bi-dimensional:\n\t\t\to que consta no primeiro index indica a listagem\n\t\t\tdas tags e, no segundo, a quantidade de ocorrências.\n\t\t*/\n\t\treturn [topTags, eventNumber];\n\t}\n\n\trender() {\n\t\tconst topTags = this.lookingForTags()[0];\n\t\tconst eventNumber = this.lookingForTags()[1];\n\t\tconst showTopTags = [];\n\t\t/*\n\t\t\tPara listar as 5 tags que mais se repetem, a cada iteração,\n\t\t\té obtido o index daquela de maior ocorrência;\n\t\t\testa é inserida no array showTopTags para ser renderizada;\n\t\t\tna sequência ela é excluída do array de tags e também do de ocorrências;\n\t\t\tassim, a próxima tag de mais relevância torna-se aquela com maior frequência\n\t\t\tdessa forma o ciclo se repete até a quinta iteração.\n\t\t*/\n\t\tfor(let i = 0; i < 5; i++) {\n\t\t\tlet max = eventNumber.reduce((a, b) => {\n\t\t\t\treturn Math.max(a, b);\n\t\t\t});\n\t\t\tlet pos = eventNumber.indexOf(max);\n\t\t\tshowTopTags.push(topTags[pos]);\n\t\t\ttopTags.splice(pos, 1);\n\t\t\teventNumber.splice(pos, 1);\n\t\t}\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t{showTopTags.map((each, k) => (\n\t\t\t\t\t<p key={k}>{each}</p>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default TopTags;\n"]},"metadata":{},"sourceType":"module"}